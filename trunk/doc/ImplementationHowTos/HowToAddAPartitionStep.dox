namespace SExtractor {

/** \page howto_add_partition_step HowTo add a new PartitionStep

\tableofcontents

The %Partition stage is where the rough detections of the %Segmentation stage
can be broken down in multiple ones, using more complex algorithms. The
Partition class itself does not implement any specific algorithm, it is just
responsible for running a number of PartitionStep%s (which implement the
algorithm logic). The rest of this HowTo describes the actions that need to be
performed to add a new algorithm as a PartitionStep and to use it within the
%SExtractor framework.

Note that %SExtractor defines all its classes in the namespace SExtractor. The
following coding snippets assumed that the code is in the SExtractor namespace
for brevity.


\section partition_step_impl Implementing the PartitionStep interface

\subsection algo_class_creation Creating the algorithm class

The first thing you need to do is to implement your algorithm logic. This is
done by creating a class which implements the PartitionStep interface:

\code{.cpp}
#include "SEFramework/Pipeline/Partition.h"

class ExamplePartitionStep : public PartitionStep {

public:

  virtual ~ExamplePartitionStep() = default;
  
  std::vector<std::shared_ptr<SourceInterface>> partition(
                       std::shared_ptr<SourceInterface> source) const override {

    // Your algorithm logic goes here

    return {source};
  }

};
\endcode

The partitioning algorithm logic is implemented in the partition() method. This
method gets as input the source to apply the algorithm to and it returns a
vector of sources, which is the result of the partitioning. Note that if you do
not want to partition the source, you can just return the input source, as shown
at the example.

\subsection access_input_info Accessing the information of the input source

Retrieving the input source information which is needed by the partitioning
algorithm is done via using the methods provided by the SourceInterface class.
For example, the following gives access to the sources pixel coordinates:

\code{.cpp}
#include "SEImplementation/Property/PixelCoordinateList.h"

  // inside the partition() method
  auto& pixel_coords = source->getProperty<PixelCoordinateList>();
\endcode

The full list of the properties provided by SExtractor can be found at the API
documentation of the Property class (inheritance diagram). If you need a custom
property computed specifically for your partition step, you can refer to
\ref howtoaddsourceproperty. 

\subsection creating_new_sources Spliting a source

If your algorithm decides that a source should be partitioned, you will need to
create new instances of concrete implementations of the SourceInterface. To keep
your PartitionStep implementation as flexible as possible, you should not create
sources of a specific type yourself. Instead, you can delegate the creation of
the sources to a SourceFactory instance, which you can get at your constructor.
The following code shows how to modify the example class accordingly:

\code{.cpp}
#include "SEFramework/Source/SourceFactory.h"

class ExamplePartitionStep : public PartitionStep {

public:

  ExamplePartitionStep(std::shared_ptr<SourceFactory> factory) : m_factory(factory) {
  }

private:

  std::shared_ptr<SourceFactory> m_factory;

};
\endcode

The SourceFactory itself is an abstract class, which is not bounded to any
concrete implementation of the SourceInterface. This gives to your PartitionStep
the ability to work with any type of sources. You only have to create them via
the factory and set their PixelCoordinateList, according the results of your
algorithm. The following code shows an example of how to split the source in
two:

\code{.cpp}
    auto& original_list = pixel_coords.getCoordinateList();
    
    std::vector<PixelCoordinate> first_half {original_list.begin(),
                                             original_list.begin() + original_list.size()};
    auto first_source = m_factory->createSource();
    first_source->setProperty<PixelCoordinateList>(first_half);
    
    std::vector<PixelCoordinate> second_half {original_list.begin() + original_list.size(),
                                             original_list.end()};
    auto second_source = m_factory->createSource();
    second_source->setProperty<PixelCoordinateList>(second_half);
    
    return {first_source, second_source};
\endcode

Note that you only have to set the PixelCoordinateList property on the sources
you create (which is the result of your partitioning). %SExtractor is going to
compute the rest of the properties for your newly created sources, if they are
needed.

The following code snipset contains the full code of the ExamplePartitionStep,
for the case you want to copy-paste it:

\code{.cpp}
#include "SEFramework/Pipeline/Partition.h"
#include "SEImplementation/Property/PixelCoordinateList.h"
#include "SEFramework/Source/SourceFactory.h"

namespace SExtractor {

class ExamplePartitionStep : public PartitionStep {
  
public:
  
  ExamplePartitionStep(std::shared_ptr<SourceFactory> factory) : m_factory(factory) {
  }

  virtual ~ExamplePartitionStep() = default;
  
  std::vector<std::shared_ptr<SourceInterface>> partition(
                        std::shared_ptr<SourceInterface> source) const override {
    
    auto& pixel_coords = source->getProperty<PixelCoordinateList>();
    
    auto& original_list = pixel_coords.getCoordinateList();
    
    std::vector<PixelCoordinate> first_half {original_list.begin(),
                                             original_list.begin() + original_list.size()};
    auto first_source = m_factory->createSource();
    first_source->setProperty<PixelCoordinateList>(first_half);
    
    std::vector<PixelCoordinate> second_half {original_list.begin() + original_list.size(),
                                             original_list.end()};
    auto second_source = m_factory->createSource();
    second_source->setProperty<PixelCoordinateList>(second_half);
    
    return {first_source, second_source};
  }
  
private:
  
  std::shared_ptr<SourceFactory> m_factory;
  
};

} // end of SExtractor namespace
\endcode

*/
}