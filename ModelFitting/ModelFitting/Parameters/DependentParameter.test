/**
 * @file DependentParameter.h
 *
 * Created on: July 30, 2015
 *     Author: Pierre Dubath and Nikolaos Apostolakos
 */

#ifndef DEPENDENT_PARAMETER_H_
#define DEPENDENT_PARAMETER_H_

#include <string>
#include <iostream>
#include <vector>
#include <memory>
#include <functional>

#include "ModelFitting/Parameters/BasicParameter.h"

namespace ModelFitting {

template<typename Parent>
class WatcherForDependentParameter;


/**
 * @class DependentParameter
 * @brief
 * 		Simplest implementation of a parameter class
 *
 * @details
 * 		Simplest implementation of the abstract base class representing any parameter
 *
 */
class DependentParameter: public BasicParameter {

public:

  using ValueCalculator = std::function<double(std::vector<BasicParameter>)>;

  DependentParameter(ValueCalculator value_calculator,
      std::vector<BasicParameter> parameters) : m_value_calculator(value_calculator) {
    for(BasicParameter& bp : parameters) {
      m_parameter_values.push_back(bp.getValue());
    }
  }

  /**
   * @brief
   *    The pure virtual setValue method
   * @details
   *    This method must be implemented in all implementation of this base class
   * @param value
   *    The value of the parameter
   *
   */
  std::vector<double> getInputParameterValues() const {
    return m_parameter_values;
  }

private:

  /// The value calculator
  ValueCalculator m_value_calculator;

  /// The values of the basics parameters
  std::vector<double> m_parameter_values {};

  //std::array<WatcherForDependentParameter<DependentParameter<Parameters...>>, sizeof...(Parameters)> m_parameter_watchers {};

};

/**
 * @class WatcherForDependentParameter
 * @brief
 *    The parameter update notification
 *
 * @details
 *
 *
 */
//template<typename Parent>
//class WatcherForDependentParameter: public ParameterWatcher {
//
//public:
//  /**
//   * @brief Destructor
//   */
//  virtual ~WatcherForDependentParameter() {
//  }
//
//private:
//
//  //WatcherForDependentParameter() = delete;
//
//  WatcherForDependentParameter(const int index, const Parent& parent) :
//      m_index(index), m_parent(parent) {
//
//  }
//
//  /**
//   * @brief
//   *    The pure virtual updatedValue(double new_value) method
//   * @details
//   *    The implementation must define the operations that the
//   *    ParameterWather wants to carry out when the parameter
//   *    value is updated. and provided through this method.
//   *
//   * @param new_value
//   *    The updated value of the parameter
//   *
//   */
//  void updatedValue(double new_value) {
//    //m_dependent_parameter.updatedValue(new_value, m_index);
//  }
//
//  const int m_index { };
//
//  const Parent m_parent;
//
//  template<typename ... Parameters>
//  friend class DependentParameter;
//
//};
//
//template<typename ... Parameters>
//DependentParameter<Parameters...> createDependentParameter(
//    typename DependentParameter<Parameters...>::ValueCalculator value_calculator,
//    Parameters &... parameters) {
//  return DependentParameter<Parameters...> { value_calculator, parameters... };
//}


DependentParameter createDependentParameter(
    typename DependentParameter::ValueCalculator value_calculator,
    std::vector<BasicParameter> parameters) {
  return DependentParameter { value_calculator, parameters};
}

} // namespace ModelFitting

#endif /* DEPENDENT_PARAMETER_H_ */
