/*
 * CompactExponentialModel.icpp
 *
 *  Created on: Aug 19, 2019
 *      Author: mschefer
 */

namespace ModelFitting {

template<typename ImageType>
CompactExponentialModel<ImageType>::CompactExponentialModel(
    std::shared_ptr<BasicParameter> i0, std::shared_ptr<BasicParameter> k,
    std::shared_ptr<BasicParameter> x_scale, std::shared_ptr<BasicParameter> y_scale,
    std::shared_ptr<BasicParameter> rotation, double width, double height,
    std::shared_ptr<BasicParameter> x, std::shared_ptr<BasicParameter> y,
    std::tuple<double, double, double, double> transform)
      : CompactModelBase<ImageType>(x_scale, y_scale, rotation, width, height, x, y, transform),
        m_i0(i0), m_k(k)
{}

template<typename ImageType>
inline float CompactExponentialModel<ImageType>::evaluateModel(const Mat22& transform, float x, float y) const {
  float x2 = x * transform[0] + y * transform[1];
  float y2 = x * transform[2] + y * transform[3];
  float r = std::sqrt(x2*x2 + y2*y2);

  return float(m_i0->getValue()) * std::exp(float(-m_k->getValue() * r));
}

template<typename ImageType>
double CompactExponentialModel<ImageType>::getValue(double x, double y) const {
  auto transform = getCombinedTransform(1.0);
  auto area_correction = (1.0 / fabs(m_jacobian[0] * m_jacobian[3] - m_jacobian[1] * m_jacobian[2]));
  return evaluateModel(transform, x, y) * area_correction;
}

template<typename ImageType>
ImageType CompactExponentialModel<ImageType>::getRasterizedImage(double pixel_scale, std::size_t size_x, std::size_t size_y) const {
  //std::cout << "]] " << getX() << " " << getY() << "\n";
  using Traits = ImageTraits<ImageType>;

  if (size_x % 2 == 0 || size_y % 2 == 0) {
    throw Elements::Exception() << "Rasterized image dimensions must be odd numbers "
        << "but got (" << size_x << ',' << size_y << ")";
  }

  ImageType image = Traits::factory(size_x, size_y);

  auto transform = getCombinedTransform(pixel_scale);
  float area_correction = (1.0 / fabs(m_jacobian[0] * m_jacobian[3] - m_jacobian[1] * m_jacobian[2])) * pixel_scale * pixel_scale;

  for (std::size_t x=0; x<size_x; ++x) {
    float x_model = x - (size_x-1) / 2.;
    for (std::size_t y=0; y<size_y; ++y) {
      float y_model = y - (size_y-1) / 2.;
      Traits::at(image, x, y) = evaluateModel(transform, x_model, y_model) * area_correction;
    }
  }

  return image;
}

}

